module simpleaes;

import deimos.openssl.crypto;
import deimos.openssl.rand;
import deimos.openssl.evp;
import std.base64;
import std.conv;
import std.exception;
import std.format;
import std.stdio;
import std.outbuffer;

/**
 * SimpleAESException throws a custom exception signifying that there was an error
 * handling a AES encryption method
 *
 * Params:
 *  message = A message to display when exception is thrown
 */
class SimpleAESException : Exception {
    this(string message, string file = __FILE__, size_t line = __LINE__) {
        super(message, file, line);
    }
}

/**
 * Initialization functions require an int value to determine whether to encypt
 * or decrypt. 0 = Dycrypt, 1 = Encrypt
 */
enum SimpleAESEnc {
    DECRYPT,
    ENCRYPT
}

/**
 * SimpleAES wraps the OpenSSL EVP API and gives a simple way to encypyt and
 * dycrypt values using AES CBC or CTR with a key size of either 128, 192, or
 * 256 bits.
 *
 * The mode can be set by passing in a EVP function which returns EVP_CIPHER*
 *
 * @param mode = The mode with which to encypt/decypt the message \n
 * @param key = The (128, 192, 256) bit key \n
 * @param iv = The 16 bit initialization vector \n
 *
 * @throws SimpleAESException
 */
struct SimpleAES {
    private const(EVP_CIPHER)* mode;
    private ulong cipherMode;
    private int keyLength;
    private int ivLength;
    private int blockSize;
    private EVP_CIPHER_CTX* cipherContext;

    ubyte[] key;
    ubyte[] iv;

    this(const(EVP_CIPHER)* mode, ubyte[] key, ubyte[] iv) {
        setMode(mode);
        loadCipher(key, iv);
    }

    this(const(EVP_CIPHER)* mode, ubyte[] key, bool dataHasIv) {
        setMode(mode);
        loadCipher(key, dataHasIv);
    }

    this(const(EVP_CIPHER)* mode, string key, string iv) {
        setMode(mode);
        loadCipher(stringToByte(key), stringToByte(iv));
    }

    this(const(EVP_CIPHER)* mode, string key, bool dataHasIv) {
        setMode(mode);
        loadCipher(stringToByte(key), dataHasIv);
    }

    ~this() {
        if (this.cipherContext) {
            EVP_CIPHER_CTX_free(this.cipherContext);
        }
    }

    ubyte[] encrypt(string data) {
        if (EVP_CipherInit_ex(this.cipherContext, this.mode, null,
                this.key.ptr, this.iv.ptr, SimpleAESEnc.ENCRYPT) != 1) {
            throw new SimpleAESException("Error initializing cipher during encryption.");
        }

        const(ubyte)[] payload = applyCipher(data);

        return (this.iv ~ payload);
    }

    string decrypt(ubyte[] data) {
        // Data comes in as iv then payload
        const(ubyte)[] dataIv = data[0 .. this.ivLength];
        const(ubyte)[] dataPayload = data[this.ivLength .. $];

        if (EVP_CipherInit_ex(this.cipherContext, this.mode, null,
                this.key.ptr, dataIv.ptr, SimpleAESEnc.DECRYPT) != 1) {
            throw new SimpleAESException("Error initializing cipher during decryption");
        }

        OutBuffer buffer = new OutBuffer();
        buffer.write(applyCipher(dataPayload));

        return buffer.toString();
    }

    private void setMode(const(EVP_CIPHER)* mode) {
        this.mode = mode;
        this.cipherMode = EVP_CIPHER_mode(mode);
        this.keyLength = EVP_CIPHER_key_length(mode);
        this.ivLength = EVP_CIPHER_iv_length(mode);
        this.blockSize = EVP_CIPHER_block_size(mode);
    }

    private void loadCipher(ubyte[] key, ubyte[] iv) {
        // Load the cipher and initialize the cipher context
        EVP_add_cipher(this.mode);
        this.cipherContext = EVP_CIPHER_CTX_new();

        // Validate the key and iv lengths
        if (key.length != this.keyLength) {
            throw new SimpleAESException(format("Invalid key length. Expected %d got %d",
                    this.keyLength, key.length));
        }

        if (iv.length != this.ivLength) {
            throw new SimpleAESException(format("Invalid iv length. Expected %d got %d",
                    this.ivLength, iv.length));
        }

        this.key = key;
        this.key.length = key.length;

        this.iv = iv;
        this.iv.length = iv.length;
    }

    /// Override where the IV is generated by calling OpenSSL's RAND_bytes
    private void loadCipher(ubyte[] key, bool dataHasIv) {
        // Load the cipher and initialize the cipher context
        EVP_add_cipher(this.mode);
        this.cipherContext = EVP_CIPHER_CTX_new();

        // Validate the key length
        if (key.length != this.keyLength) {
            throw new SimpleAESException(format("Invalid key length. Expected %d got %d",
                    this.keyLength, key.length));
        }

        // If the data we are decrypting already contains an IV then we don't
        // need to waste any time generating one
        if (!dataHasIv) {
            this.iv.length = this.ivLength;

            // Generate a secure IV of length this.ivLength
            if (RAND_bytes(this.iv.ptr, this.ivLength) != 1) {
                throw new SimpleAESException("Failed to generate secure random bytes for IV");
            }
        }

        this.key = key;
        this.key.length = key.length;
    }

    private ubyte[] applyCipher(const(ubyte)[] data) {
        ubyte[] buffer;
        int outputPtrUpdate, outputPtrFinal;

        // Make sure we have enough room in the buffer for any additional bytes
        // passed in by CipherFinal
        buffer.length = data.length + this.blockSize;

        if (EVP_CipherUpdate(this.cipherContext, buffer.ptr, &outputPtrUpdate,
                data.ptr, data.length.to!int) != 1) {
            throw new SimpleAESException("Failed while updating the cipher");
        }

        // Append any final bytes to the buffer
        if (EVP_CipherFinal_ex(this.cipherContext, buffer.ptr + outputPtrUpdate,
                &outputPtrFinal) != 1) {
            throw new SimpleAESException("Failed while finalizing the cipher");
        }

        // Stupid hack because hacking a entirely correct buffer size for both
        // cipher modes would be even uglier
        buffer.length = (outputPtrUpdate + outputPtrFinal);

        return buffer;
    }

    private ubyte[] applyCipher(const(char)[] data) {
        return applyCipher(cast(const(ubyte)[]) data);
    }

    private ubyte[] stringToByte(string input) const {
        return cast(ubyte[]) input;
    }
}

/// Make sure the correct key length is set when the constructor is called
@system unittest {
    const(SimpleAES) aes128 = SimpleAES(EVP_aes_128_cbc(), "951253F399F47357", "F3D2C116F92A7357");

    assert(aes128.keyLength == 16);

    const(SimpleAES) aes192 = SimpleAES(EVP_aes_192_cbc(),
            "5A7CB53F13B3EHBNDHES7357", "752FDB9623927357");

    assert(aes192.keyLength == 24);

    const(SimpleAES) aes256 = SimpleAES(EVP_aes_256_ctr(),
            "7456BD9BD763SQWXN3U4D2341SCD7357", "3S2F8C83C8917357");

    assert(aes256.keyLength == 32);
}

/// Make sure that when an IV is not specified the generated IV conforms to the
/// correct length
@system unittest {
    SimpleAES aes128 = SimpleAES(EVP_aes_128_cbc(), "1234567890123456", false);

    assert(aes128.ivLength == 16);

    ubyte[] test = aes128.encrypt("Hello world! homi");

    SimpleAES aes128Dec = SimpleAES(EVP_aes_128_cbc(), "1234567890123456", true);

    string testing = aes128Dec.decrypt(test);
    
    writeln(testing);
}

/// Make sure that the correct cipherMode is set when the constructor is called
@system unittest {
    const(SimpleAES) aesCBC = SimpleAES(EVP_aes_128_cbc(), "99C66FAB1AA77357", "BDA7991A3B5D7357");

    assert(aesCBC.cipherMode == EVP_CIPH_CBC_MODE);

    const(SimpleAES) aesCTR = SimpleAES(EVP_aes_128_ctr(), "6948A76371417357", "9425689BC7247357");

    assert(aesCTR.cipherMode == EVP_CIPH_CTR_MODE);
}

/// Make sure that exceptions are thrown only when expected
@system unittest {
    assertThrown!SimpleAESException(SimpleAES(EVP_aes_128_cbc(), "TooShort", "58A625D84E7C7357"));

    assertThrown!SimpleAESException(SimpleAES(EVP_aes_128_cbc(), "H6S39DHE7SGD7357", "TooShort"));

    assertNotThrown!SimpleAESException(SimpleAES(EVP_aes_128_cbc(),
            "8DHFGEYSTEBC7357", "02BPAYCWLD0C7357"));
}
